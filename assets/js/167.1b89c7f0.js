(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{591:function(t,a,s){"use strict";s.r(a);var v=s(25),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"opencv-python-02-几何及灰度变换、图像增强"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#opencv-python-02-几何及灰度变换、图像增强"}},[t._v("#")]),t._v(" Opencv-Python 02 几何及灰度变换、图像增强")]),t._v(" "),s("h3",{attrs:{id:"_1-简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[t._v("#")]),t._v(" 1 简介")]),t._v(" "),s("p",[t._v("图像的几何及灰度变换操作较为常用，图像增强操作不仅仅只在深度学习中用作数据增广、在实际应用中图像增强技术也能改善图像质量，给人以更好的体验。在深度学习领域，我们常用平移、旋转、镜像等操作进行数据增广；在传统CV领域，由于某些拍摄角度的问题，我们需要对图像进行矫正处理，而几何变换正是这个处理过程的基础，因此了解和学习几何变换也是有必要的。")]),t._v(" "),s("h3",{attrs:{id:"_2-算法理论介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法理论介绍"}},[t._v("#")]),t._v(" 2 算法理论介绍")]),t._v(" "),s("h4",{attrs:{id:"_2-1-仿射变换形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-仿射变换形式"}},[t._v("#")]),t._v(" 2.1 仿射变换形式")]),t._v(" "),s("p",[t._v("需要一个仿射变换矩阵，与原坐标(v.w) 做仿射变换(点乘)后，得到变换后的坐标(x,y)。常用的变换矩阵及作用如下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/picgo/image-20200423211344537.png#vwid=569&vhei=109",alt:"image-20200423211344537"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://muyun-blog-pic.oss-cn-shanghai.aliyuncs.com/picgo/image-20200423211531691.png#vwid=714&vhei=384",alt:"image-20200423211531691"}})]),t._v(" "),s("h4",{attrs:{id:"_2-2-坐标系变换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-坐标系变换"}},[t._v("#")]),t._v(" 2.2 坐标系变换")]),t._v(" "),s("p",[t._v("变换中心，对于缩放、平移可以以图像坐标原点（图像左上角为原点）为中心变换，这不用坐标系变换，直接按照一般形式计算即可。而对于旋转和偏移，一般是以图像中心为原点，那么这就涉及坐标系转换了。")]),t._v(" "),s("p",[t._v("图像坐标的原点在图像左上角，水平向右为 X 轴，垂直向下为 Y 轴。数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴，称为笛卡尔坐标系。")]),t._v(" "),s("p",[t._v("因此，对于旋转和偏移，就需要3步（3次变换）：")]),t._v(" "),s("ul",[s("li",[t._v("将输入原图图像坐标转换为笛卡尔坐标系；")]),t._v(" "),s("li",[t._v("进行旋转计算。旋转矩阵前面已经给出了；")]),t._v(" "),s("li",[t._v("将旋转后的图像的笛卡尔坐标转回图像坐标。")])]),t._v(" "),s("h4",{attrs:{id:"_2-3-反向映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-反向映射"}},[t._v("#")]),t._v(" 2.3 反向映射")]),t._v(" "),s("p",[t._v("前向映射就是根据原图用变换公式直接算出输出图像相应像素的空间位置，那么这会导致一个问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的蜂窝状）。更好的一种方式是采用 反向映射（Inverse Mapping）：扫描输出图像的位置(x,y)，通过")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200413005247477.png#vwid=180&vhei=21",alt:"Image"}}),t._v("\n（为T的逆矩阵）计算输入图像对应的位置 (v,w)，通过插值方法决定输出图像该位置的灰度值。")]),t._v(" "),s("h4",{attrs:{id:"_2-4-插值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-插值"}},[t._v("#")]),t._v(" 2.4 插值")]),t._v(" "),s("p",[t._v("采用反向映射后，需通过插值方法决定输出图像该位置的值，因此需要选择插值算法。通常有最近邻插值、双线性插值，双三次插值等，OpencV默认采用双线性插值，我们也就采用双线性插值。")])])}),[],!1,null,null,null);a.default=_.exports}}]);